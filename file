import tkinter as tk
from tkinter import ttk, messagebox, font
import pandas as pd
import os
import sys
import vertica_python

class MigrationConfiguratorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Data Migration Validation Configurator")
        self.root.geometry("750x650")
        self.root.minsize(700, 600)

        self.table_data = {}
        self.table_names = []
        self.current_table_index = 0
        self.output_records = []
        self.column_vars = []
        self.is_table_staged = False

        self.input_file = 'input_columns.xlsx'
        self.output_file = 'output_config.xlsx'

        self.setup_styles()
        self.create_widgets()
        
        self.initialize_data_source()

    def _get_db_credentials(self):
        """Fetches database credentials from environment variables."""
        credentials = {
            'host': os.environ.get('VERTICA_HOST'),
            'db': os.environ.get('VERTICA_DB'),
            'user': os.environ.get('VERTICA_USER'),
            'password': os.environ.get('VERTICA_PASSWORD'),
            'schema': 'ER1'
        }
        missing = [key for key, value in credentials.items() if value is None and key != 'schema']
        if missing:
            messagebox.showerror(
                "Environment Variables Missing",
                f"The following required environment variables are not set:\n\n{', '.join(missing).upper()}"
            )
            return None
        return credentials

    def _connect_to_vertica(self, host, db, user, password):
        """Establishes a connection to production Vertica."""
        self.log_message(f"Connecting to {host}...")
        return vertica_python.connect(
            host=host,
            port=5433,
            user=user,
            password=password,
            database=db,
            autocommit=True
        )

    def _create_input_file_from_vertica(self, creds):
        """Fetches data from Vertica and creates the input Excel file."""
        all_data = []
        conn = None
        try:
            conn = self._connect_to_vertica(creds['host'], creds['db'], creds['user'], creds['password'])
            self.log_message("Connection successful.", "SUCCESS")
            
            with conn.cursor() as cur:
                self.log_message(f"Fetching tables from schema '{creds['schema']}'...")
                cur.execute("SELECT table_name FROM v_catalog.tables WHERE table_schema = %s", (creds['schema'],))
                tables = [row[0] for row in cur.fetchall()]
                
                self.log_message(f"Found {len(tables)} tables. Fetching columns...")
                for i, table in enumerate(tables):
                    self.log_message(f"Processing table {i+1}/{len(tables)}: {table}")
                    cur.execute("SELECT column_name FROM v_catalog.columns WHERE table_schema = %s AND UPPER(table_name) = UPPER(%s)", (creds['schema'], table))
                    columns = [row[0] for row in cur.fetchall()]
                    for col in columns:
                        all_data.append({'table_name': table, 'column_name': col})

            df = pd.DataFrame(all_data)
            df.to_excel(self.input_file, index=False)
            self.log_message(f"Successfully created '{self.input_file}' with {len(df)} total columns.", "SUCCESS")
            return True

        except Exception as e:
            self.log_message(f"An error occurred: {e}", "ERROR")
            messagebox.showerror("Vertica Error", f"Failed to fetch data from Vertica:\n\n{e}")
            return False
        finally:
            if conn:
                conn.close()
                self.log_message("Connection to Vertica closed.")

    def initialize_data_source(self):
        """Main method to initialize the app by creating the input file from Vertica."""
        creds = self._get_db_credentials()
        if not creds:
            self.root.destroy()
            return

        if self._create_input_file_from_vertica(creds):
            if not os.path.exists(self.output_file):
                pd.DataFrame(columns=['table_name', 'flag', 'column_name']).to_excel(self.output_file, index=False)
            self.load_data()
        else:
            self.root.destroy()

    def setup_styles(self):
        """Configures the visual style for the ttk widgets."""
        self.style = ttk.Style(self.root)
        self.style.theme_use('clam')
        self.title_font = font.Font(family="Helvetica", size=16, weight="bold")
        self.label_font = font.Font(family="Helvetica", size=12)
        self.bold_label_font = font.Font(family="Helvetica", size=12, weight="bold")
        self.log_font = font.Font(family="Courier", size=10)
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('TLabel', background='#f0f0f0', font=self.label_font)
        self.style.configure('Title.TLabel', font=self.title_font, foreground='#333')
        self.style.configure('Header.TLabel', font=self.bold_label_font, foreground='#003366')
        self.style.configure('TRadiobutton', background='#f0f0f0', font=self.label_font)
        self.style.configure('TCheckbutton', background='#f0f0f0', font=self.label_font)
        self.style.configure('TButton', font=self.label_font, padding=6)
        self.style.map('TButton',
            foreground=[('active', 'white'), ('!disabled', '#333')],
            background=[('active', '#0078d7'), ('!disabled', '#e0e0e0')]
        )
        self.style.configure('Success.TButton', background='#28a745', foreground='white')
        self.style.map('Success.TButton', background=[('active', '#218838')])

    def create_widgets(self):
        """Creates and lays out all the GUI widgets."""
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        top_frame = ttk.Frame(main_frame, padding="10")
        top_frame.pack(fill=tk.X, pady=(0, 10))
        top_frame.columnconfigure(1, weight=1)
        
        ttk.Label(top_frame, text="Current Table:", style='Header.TLabel').grid(row=0, column=0, sticky="w", pady=(0,10))
        self.table_name_label = ttk.Label(top_frame, text="...", style='Title.TLabel')
        self.table_name_label.grid(row=0, column=1, sticky="w", pady=(0,10))

        ttk.Label(top_frame, text="Select Flag:", style='Header.TLabel').grid(row=1, column=0, sticky="w", pady=(5,10))
        self.flag_var = tk.StringVar()
        self.flag_frame = ttk.Frame(top_frame)
        self.flag_frame.grid(row=1, column=1, sticky="w")
        ttk.Radiobutton(self.flag_frame, text="Key", variable=self.flag_var, value="key", command=self.on_flag_change).pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(self.flag_frame, text="Exclude", variable=self.flag_var, value="exclude", command=self.on_flag_change).pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(self.flag_frame, text="Stage (Skip Table)", variable=self.flag_var, value="stage", command=self.on_flag_change).pack(side=tk.LEFT, padx=5)

        columns_outer_frame = ttk.Frame(main_frame)
        columns_outer_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        ttk.Label(columns_outer_frame, text="Select Columns (if applicable):", style='Header.TLabel').pack(anchor="w", padx=10)
        
        canvas = tk.Canvas(columns_outer_frame, bg='#ffffff', highlightthickness=0)
        scrollbar = ttk.Scrollbar(columns_outer_frame, orient="vertical", command=canvas.yview)
        self.columns_frame = ttk.Frame(canvas, style='TFrame')
        self.columns_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=self.columns_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True, padx=(10,0), pady=5)
        scrollbar.pack(side="right", fill="y", padx=(0,10), pady=5)

        action_frame = ttk.Frame(main_frame)
        action_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=(10, 0))
        action_frame.columnconfigure((0, 1, 2, 3), weight=1)

        self.prev_button = ttk.Button(action_frame, text="Previous Table", command=self.previous_table)
        self.prev_button.grid(row=0, column=0, padx=5, sticky="ew")

        self.apply_button = ttk.Button(action_frame, text="Apply Selections", command=self.apply_selection)
        self.apply_button.grid(row=0, column=1, padx=5, sticky="ew")

        self.next_button = ttk.Button(action_frame, text="Next Table", command=self.next_table)
        self.next_button.grid(row=0, column=2, padx=5, sticky="ew")
        
        self.finish_button = ttk.Button(action_frame, text="Finish & Save", command=self.finalize_process, style='Success.TButton')
        self.finish_button.grid(row=0, column=3, padx=5, sticky="ew")

        log_frame = ttk.LabelFrame(main_frame, text="Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, side=tk.BOTTOM, pady=(15,0))
        self.log_text = tk.Text(log_frame, height=8, wrap=tk.WORD, state=tk.DISABLED, font=self.log_font, bg="#fdfdfd", relief=tk.SOLID, borderwidth=1)
        self.log_text.pack(fill=tk.BOTH, expand=True)

    def log_message(self, message, level="INFO"):
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, f"[{level}] {message}\n")
        self.log_text.config(state=tk.DISABLED)
        self.log_text.see(tk.END)

    def load_data(self):
        try:
            df = pd.read_excel(self.input_file)
            if 'table_name' not in df.columns or 'column_name' not in df.columns:
                messagebox.showerror("Error", "Input Excel must contain 'table_name' and 'column_name' columns.")
                self.root.quit()
                return
            
            self.table_data = df.groupby('table_name')['column_name'].apply(list).to_dict()
            self.table_names = list(self.table_data.keys())

            if not self.table_names:
                messagebox.showerror("Error", "No data found in the input file.")
                self.apply_button.config(state=tk.DISABLED)
                self.next_button.config(state=tk.DISABLED)
            else:
                self.display_current_table()
                self.log_message(f"Successfully loaded {len(self.table_names)} tables from '{self.input_file}'.")

        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while loading data: {e}")
            self.root.quit()

    def display_current_table(self):
        for widget in self.columns_frame.winfo_children():
            widget.destroy()
        self.column_vars.clear()
        self.is_table_staged = False
        self.prev_button.config(state=tk.NORMAL if self.current_table_index > 0 else tk.DISABLED)
        self.next_button.config(state=tk.NORMAL)
        self.apply_button.config(state=tk.NORMAL)
        table_name = self.table_names[self.current_table_index]
        columns = self.table_data[table_name]
        self.table_name_label.config(text=table_name)
        self.log_message(f"--- Now processing table: '{table_name}' ---")
        for i, col in enumerate(columns):
            var = tk.IntVar()
            cb = ttk.Checkbutton(self.columns_frame, text=col, variable=var)
            cb.grid(row=i, column=0, sticky='w', padx=10, pady=2)
            self.column_vars.append((var, col))
        self.reset_ui_for_new_selection()

    def reset_ui_for_new_selection(self):
        self.flag_var.set("")
        for var, _ in self.column_vars:
            var.set(0)
        self.on_flag_change()
        self.apply_button.config(state=tk.NORMAL)
        for child in self.flag_frame.winfo_children():
            child.config(state=tk.NORMAL)

    def on_flag_change(self):
        selected_flag = self.flag_var.get()
        state = tk.NORMAL if selected_flag in ["key", "exclude"] else tk.DISABLED
        for widget in self.columns_frame.winfo_children():
            if isinstance(widget, ttk.Checkbutton):
                widget.config(state=state)

    def apply_selection(self):
        flag = self.flag_var.get()
        if not flag:
            messagebox.showwarning("Selection Missing", "You must select a flag before applying.")
            return
        table_name = self.table_names[self.current_table_index]
        selected_columns = [col_name for var, col_name in self.column_vars if var.get() == 1]
        if flag in ["key", "exclude"] and not selected_columns:
            messagebox.showwarning("Selection Missing", f"You must select one or more columns to mark as '{flag}'.")
            return
        if flag == "stage":
            self.output_records.append({'table_name': table_name, 'flag': 'stage', 'column_name': None})
            self.log_message(f"Table '{table_name}' marked as 'stage'. It will be skipped.", "SUCCESS")
            self.is_table_staged = True
            self.apply_button.config(state=tk.DISABLED)
            for child in self.flag_frame.winfo_children():
                child.config(state=tk.DISABLED)
        else:
            for col in selected_columns:
                self.output_records.append({'table_name': table_name, 'flag': flag, 'column_name': col})
                self.log_message(f"Column '{col}' in table '{table_name}' marked as '{flag}'.")
            self.reset_ui_for_new_selection()

    def save_records_to_excel(self, is_final=False):
        if not self.output_records:
            if is_final:
                messagebox.showwarning("Nothing to Save", "No new configurations were applied.")
                return False
            return True
        try:
            new_df = pd.DataFrame(self.output_records)
            try:
                existing_df = pd.read_excel(self.output_file)
                combined_df = pd.concat([existing_df, new_df], ignore_index=True)
            except (FileNotFoundError, ValueError):
                combined_df = new_df
            combined_df.to_excel(self.output_file, index=False)
            if self.output_records:
                self.log_message(f"Saved {len(self.output_records)} new configurations to '{self.output_file}'.", "SUCCESS")
            self.output_records.clear()
            return True
        except Exception as e:
            messagebox.showerror("Save Error", f"Failed to save output file: {e}")
            return False

    def previous_table(self):
        self.save_records_to_excel()
        if self.current_table_index > 0:
            self.current_table_index -= 1
            self.display_current_table()
            self.log_message(f"Moved back to previous table.")

    def next_table(self):
        self.save_records_to_excel()
        if self.current_table_index < len(self.table_names) - 1:
            self.current_table_index += 1
            self.display_current_table()
        else:
            self.log_message("Reached the last table. You can go back, or click 'Finish & Save' to complete.", "INFO")
            self.next_button.config(state=tk.DISABLED)
            messagebox.showinfo(
                "Process Complete",
                "You have reached the last table.\n\n"
                "You can still use the 'Previous Table' button to review or change earlier selections.\n\n"
                "When you are finished, click 'Finish & Save' to generate the output file and exit."
            )

    def finalize_process(self):
        if self.save_records_to_excel(is_final=True):
            final_msg = f"Configuration complete! All data saved to '{self.output_file}'."
            self.log_message(final_msg, "SUCCESS")
            self.table_name_label.config(text="All Done!")
            for btn in [self.apply_button, self.next_button, self.prev_button]:
                btn.config(state=tk.DISABLED)
            if messagebox.askokcancel("Success", f"{final_msg}\n\nDo you want to close the application?"):
                self.root.quit()

if __name__ == "__main__":
    root = tk.Tk()
    app = MigrationConfiguratorApp(root)
    root.mainloop()
